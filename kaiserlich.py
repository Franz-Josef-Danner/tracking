"""Kaiserlich tracking addon"""

import bpy
import math

bl_info = {
    "name": "Kaiserlich Tracking",
    "author": "AutoGenerated",
    "version": (0, 1, 0),
    "blender": (4, 0, 0),
    "location": "Clip Editor > Kaiserlich",
    "category": "Tracking",
}


# -------------------------------------------------------------------
# Properties
# -------------------------------------------------------------------

def init_props():
    scene = bpy.types.Scene
    scene.kaiserlich_marker_per_frame = bpy.props.IntProperty(
        name="Marker/Frame",
        default=100,
        min=1,
        description="Desired number of markers per frame",
    )
    scene.kaiserlich_frames_per_track = bpy.props.IntProperty(
        name="Frames/Track",
        default=15,
        min=1,
        description="Minimum track length in frames",
    )
    scene.kaiserlich_error_per_track = bpy.props.FloatProperty(
        name="Error/Track",
        default=1.0,
        min=0.0,
        description="Allowed error per track",
    )


def clear_props():
    scene = bpy.types.Scene
    del scene.kaiserlich_marker_per_frame
    del scene.kaiserlich_frames_per_track
    del scene.kaiserlich_error_per_track


# -------------------------------------------------------------------
# Panel
# -------------------------------------------------------------------

class CLIP_PT_kaiserlich(bpy.types.Panel):
    bl_label = "Kaiserlich"
    bl_space_type = 'CLIP_EDITOR'
    bl_region_type = 'UI'
    bl_category = "Kaiserlich"

    @classmethod
    def poll(cls, context):
        space = context.space_data
        return space and space.mode == 'TRACKING'

    def draw(self, context):
        layout = self.layout
        scene = context.scene
        space = context.space_data

        layout.prop(scene, "kaiserlich_marker_per_frame")
        layout.prop(scene, "kaiserlich_frames_per_track")
        layout.prop(scene, "kaiserlich_error_per_track")

        row = layout.row()
        op = row.operator("clip.kaiserlich_track", text="Track")
        if not space.clip:
            row.enabled = False


# -------------------------------------------------------------------
# Helper functions
# -------------------------------------------------------------------


def detect_features_adaptive(context, clip, marker_target):
    settings = clip.tracking.settings
    width = clip.size[0]

    # Tracking defaults
    settings.default_motion_model = 'Loc'
    settings.default_pattern_match = 'KEYFRAME'
    settings.default_correlation_min = 0.9
    settings.use_red_channel = True
    settings.use_green_channel = True
    settings.use_blue_channel = True
    settings.default_pattern_size = int(width / 100)
    settings.default_search_size = int(width / 100)

    margin_base = int(width * 0.025)
    min_distance_base = int(width * 0.05)

    detection_threshold = 0.5
    marker_adapt = marker_target * 4

    min_marker = marker_adapt * 0.9
    max_marker = marker_adapt * 1.1

    iteration = 0
    while iteration < 20:
        factor = math.log10(detection_threshold * 100000000) / 8
        margin = int(margin_base * factor)
        distance = int(min_distance_base * factor)

        bpy.ops.clip.detect_features(
            threshold=detection_threshold,
            margin=margin,
            distance=distance,
        )
        tracks = [t for t in clip.tracking.objects.active.tracks if t.select]
        new_count = len(tracks)
        if min_marker < new_count < max_marker:
            break
        detection_threshold = max(
            detection_threshold * ((new_count + 0.1) / marker_adapt),
            0.0001,
        )
        bpy.ops.clip.delete_track()
        iteration += 1


# -------------------------------------------------------------------
# Operator
# -------------------------------------------------------------------

class CLIP_OT_kaiserlich_track(bpy.types.Operator):
    bl_idname = "clip.kaiserlich_track"
    bl_label = "Kaiserlich Track"
    bl_description = "Automatically track markers"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        space = context.space_data
        clip = space.clip
        if not clip:
            self.report({'ERROR'}, "No clip loaded")
            return {'CANCELLED'}

        marker_target = context.scene.kaiserlich_marker_per_frame
        detect_features_adaptive(context, clip, marker_target)
        bpy.ops.clip.track_markers(backwards=True)
        bpy.ops.clip.track_markers(forwards=True)
        return {'FINISHED'}


# -------------------------------------------------------------------
# Registration
# -------------------------------------------------------------------

classes = (CLIP_PT_kaiserlich, CLIP_OT_kaiserlich_track)


def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    init_props()


def unregister():
    clear_props()
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)


if __name__ == "__main__":
    register()
